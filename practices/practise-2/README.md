# Занятие 2. Принципы SOLID
Выпускаемые НИУ ВШЭ автомобили с педальными двигателями пользуются большим спросом, но иногда встречаются люди, которые не могут использовать новый тип автомобиля - их ноги слишком слабые, чтобы крутить педали с достаточной силой. Но студенты нашли решение для этой проблемы, выпустив новый тип двигателя - с ручным приводом. Теперь больше людей могут приобрести автомобили, выпускаемые НИУ ВШЭ. Студенты обратились к вам для доработки информационной системы под новые реалии.
## Функциональные требования
1. Информационная система должна учитывать автомобили с обоими типами двигателей
2. Автомобили с педальным приводом необходимо продавать покупателям с силой ног больше 5
3. Автомобили с ручным приводом необходимо продавать покупателям с силой рук больше 5
## Требования к реализации
1. В класс `Customer` добавить две новые характеристики:
    - Целое число, определяющее силу ног покупателя
    - Целое число, определяющее силу рук покупателя
2. Добавить интерфейс `IEngine` для описания двигателя:
    - У двигателя должен быть метод, позволяющий проверить совместимость между двигателем и покупателем
3. Класс `Engine` переименовать в `PedalEngine` и добавить реализацию интерфейса `IEngine`:
    - При реализации метода определения совместимости двигателя и покупателя учесть функциональные требования
4. Добавить реализацию интефейса `IEngine` для двигателя с ручным приводом:
    - При реализации метода определения совместимости двигателя и покупателя учесть функциональные требования
5. Для каждой реализации интерфейса `IEngine` переопределить метод `ToString` для получения информации о двигателе:
    - Метод должен возвращать тип двигателя
6. Заменить ссылку на `Engine` внутри класса `Car` на ссылку на интерфейс `IEngine`:
    - Определить конструктор, принимающий экземпляр `IEngine` и номер автомобиля
7. Добавить в класс `Car` метод для определения совместимости автомобиля с покупателем:
    - Внутри метода использовать соответствующий метод интерфейса `IEngine`
8. Добавить generic-интерфейс `ICarFactory` для создания автомобилей:
    - У интерфейса должен быть один generic-параметр `TParams`, предназначенный для параметров двигателя
    - У интерфейса должен быть метод для создания автомобилей:
        - Метод должен принимать параметр типа `TParams`
        - Метод должен принимать номер выпускаемого автомобиля
9. Добавить запись `PedalEngineParams`:
    - Класс должен иметь свойство для педачи размера педалей
10. Добавить запись `EmptyEngineParams`:
    - Определить статическое поле `DEFAULT`, содержащее экемпляр записи
11. Реализовать интерфейс `ICarFactory` для педальных автомобилей:
    - Класс должен называться `PedalCarFactory`
    - При реализации интерфейса в качестве аргумента для generic-параметра использовать `PedalEngineParams`
12. Реализовать интерфейс `ICarFactory` для автомобилей с ручным приводом:
    - Класс должен называться `HandCarFactory`
    - При реализации интерфейса в качестве аргумента для generic-параметра использовать `EmptyEngineParams`
13. Добавить интерфейс `ICarProvider`
    - У интерфейса должен быть метод для поиска подходящего автомобиля, принимающий ссылку на покупателя в качестве параметра
14. Добавить класс `CarService` для управления автомобилями:
    - У класса должна быть коллекция объектов `Car` для хранения автомобилей - при этом между автомобилями и `CarService` должно быть отношение композиции
    - Необходимо реализовать интерфейс `ICarProvider` для класса `CarService`:
        - Метод должен пробегаться по коллекции автомобилей и возвращать первый подходящий автомобиль
        - При реализации учесть, что каждый автомобиль должен быть выдан ровно 1 раз
    - У класса должен быть generic-метод для добавления автомобилей:
        - В качестве generic-параметра должен выступать тип `TParams` для описания параметров двигателя добавляемого автомобиля
        - Метод должен принимать параметр типа `ICarFactory`
        - Также метод должен принимать параметр типа `TParams`
        - В своем теле метод должен вычислять номер выпущенного автомобиля - они не должны повторяться
15. Добавить интерфейс `ICustomersProvider`:
    - Интерфейс должен содержать метод для получения списка покупателей
16. Добавить класс `CustomerStorage`
    - У класса должна быть коллекция покупателей
    - Класс должен реализовывать интерфейс `ICustomersProvider`
    - У класса должен быть метод для добавления покупателей
17. Удалить класс `HseCarFactory`
18. Добавить класс `HseCarService`:
    - Добавить ссылки на интерфейсы `ICarProvider` и `ICustomersProvider` - проинициализировать их через конструктор класса
    - Добавить метод `SellCars`:
        - Метод должен получить покупателей из `ICustomersProvider` и пробежаться по списку
        - Если у какого-то покупателя нет автомобиля - метод должен запрашивать автомобиль из `ICarProvider`
        - Если автомобиль удалось получить - метод должен назначать его покупателю
## Тестирование
1. Создать экезмпляр класса `CarService`
2. Создать экземпляр класса `CustomerStorage`
3. Создать экземпляр класса `HseCarService`
4. Создать экземпляр класса `PedalCarFactory`
5. Создать экземпляр класса `HandCarFactory`
6. Добавить следующих покупателей:
    - С силой ног 6 и силой рук 4
    - С силой ног 4 и силой рук 6
    - С силой ног 6 и силой рук 6
    - С силой ног 4 и силой рук 4
7. Добавить автомобили:
    - 2 педальных автомобиля
    - 2 автомобиля с ручным приводом
8. Вывести на экран информацию о покупателях и их автомобилях
9. Вызвать метод `SellCars`
10. Вывести на экран информацию о покупателях и их автомобилях. Проверить, что результат соответствует следующему:
    - Одному покупателю вручен педальный автомобиль
    - Одному покупателю вручен автомобиль с ручным приводом
    - Одному покупателю вручен любой автомобиль
    - Один покупатель остался без автомобиля
    - При этом у всех врученных автомобилей различные номера
## Задание на доработку
1. Написать джава док на public методы и классы
2. Добавить левитирующие машины
3. Добавить параметр iq к человеку, если больше 300, то тип двигателя левитирующий
4. Протестировать в Main путем добавления еще одного покупателя перед вручением любого двигателя
## Пояснения к реализации
Добавление интерфейса `IEngine`, объединяющего под собой все возможные двигатели, позволяет реализовать принцип подстановки Лисков.
Прием в методе класса `CarService` интерфейса `ICarFactory`, а также параметров для него позволяет нам реализовать принцип открытости-закрытости.
Выделение интерфейсов `ICarProvider` и `ICustomersProvider`, содержащих лишь необходимую часть функциональности, позволило нам реализовать принцип разделения интерфейсов.
Вынесение управления автомобилями и покупателями из `HseCarService` позволило нам реализовать принципы единственной ответственности и инверсии зависимостей.
## Диаграмма классов полученной информационной системы
Полученная информационная система будет иметь схожую диаграмму классов:
![image diagram](./diagram.png)
<details>
<summary>Исходный код</summary>
```
@startuml
class Customer {
    +int LegPower
    +int HandPower
    +Car Car
}
interface IEngine {
    +bool IsCompatible()
}
class PedalEngine {
    +int Size
}
class HandEngine {}
class Car {
    -IEngine Engine
    +bool IsCompatible()
}
interface ICarFactory {
    +Car CreateCar()
}
class PedalCarFactory {}
class HandCarFactory {}
interface ICarProvider {
    +Car TakeCar()
}
class CarService {
    +void AddCar()
}
interface ICustomersProvider {
    +Customer[] GetCustomers()
}
class CustomersStorage {
    +void AddCustomer()
}
class HseCarService {
    -ICarProvider Cars
    -ICustomersProvider Customers
    +void SellCars()
}
Car o-- IEngine
PedalEngine ..|> IEngine
HandEngine ..|> IEngine
Customer o-- Car
ICarFactory --> Car : creates
PedalCarFactory ..|> ICarFactory
HandCarFactory ..|> ICarFactory
CarService ..|> ICarProvider
CustomersStorage ..|> ICustomersProvider
HseCarService o-- ICarProvider
HseCarService o-- ICustomersProvider
CarService *-- Car
CustomersStorage o-- Customer
@enduml
```
</details>

<details> 
<summary>Ссылки</summary>
1. https://habr.com/ru/companies/itelma/articles/546372/
</details>