### **Занятие 7. Структурные паттерны: Фасад и Адаптер**
На этом занятии мы переходим к **структурным паттернам**. 
Их главная цель — организовать взаимодействие между объектами и классами в гибкую, расширяемую и удобную в использовании структуру. 
Проще говоря, они помогают складывать сложные "кирпичики" кода в прочные и логичные "конструкции".

**Сегодня мы разберем два ключевых паттерна:**
1.  **Фасад (Facade)** — чтобы *скрыть сложность*.
2.  **Адаптер (Adapter)** — чтобы *обеспечить совместимость*.

---

### **1. Почему эти паттерны важны? (Контекст)**

Представьте, что наша программа — это автомобильный завод. Есть цех по производству двигателей, цех кузовов, цех сборки и отдел продаж.

*   **Без Фасада:** Клиенту, чтобы купить машину, пришлось бы самому ходить по всем цехам, отдавать приказы инженерам и следить за сборкой. Это сложно, долго и клиент может ошибиться.
*   **Без Адаптера:** Представьте, что вы купили мощный американский двигатель, но он не встает на посадочные места вашего европейского автомобиля. Нужен переходник!

**Фасад** в нашем случае — это менеджер по продажам. Клиент общается только с ним, а менеджер уже сам координирует работу всех цехов. 
**Адаптер** — это тот самый переходник, который позволяет использовать "чужеродные" компоненты (как наш новый катамаран с колёсами) в существующей системе продаж.

---

### **2. Ваши цели на этом занятии**

1.  **Понять на практике:** Как Фасад упрощает работу со сложной системой.
2.  **Освоить:** Как Адаптер позволяет интегрировать классы с несовместимыми интерфейсами.
3.  **Реализовать:** Оба паттерна в рамках нашего проекта.

---

### **3. Задачи для реализации**

#### **Задача 1: Навести порядок с помощью Фасада**

**Проблема:** Сейчас основной код (`KpoApplicationTest`) вынужден знать обо всех внутренних компонентах системы (`CarStorage`, `CustomerStorage`, фабриках и т.д.) 
и управлять ими по отдельности. Это создает "спагетти-код", который трудно читать и поддерживать.

**Решение:** Реализовать паттерн **Фасад**.

*   **Что нужно сделать?**
    Создайте класс `Hse`, который станет **единой точкой входа** в наше приложение.

*   **Как это сделать?**
    *   Класс `Hse` должен инкапсулировать в себе все основные сервисы (хранилища, фабрики).
    *   Он должен предоставлять простые, высокоуровневые методы для клиента (в нашем случае — для тестового класса).
    *   **Примерный API класса `Hse`:**
        ```
        public class Hse {
            // ... (внутренние поля: хранилища, фабрики и т.д.)

            // Простой метод для добавления клиента. Фасад сам решит, куда его поместить.
            public void addCustomer(String name, int legPower, int handPower, int iq) { ... }

            // Простой метод для добавления педальной машины.
            public void addPedalCar(int pedalSize) { ... }

            // Простой метод для добавления ручной машины. 
            public void addHandCar() { ... }

            //TODO все методы что вам нужны
        
            // Запуск процесса продаж, продажа и машин и катамаранов! Фасад сам проведет все внутренние операции.
            public void sell() { ... }

            // Получить отчет. Фасад соберет данные из всех нужных мест.
            public String generateReport() { ... }
        }
        ```

*   **Результат:** В `KpoApplicationTest` у вас должен остаться только чистый и понятный код, работающий исключительно через объект класса `Hse`.

    **Было (хаос):**
    ```
    @Autowired
    CarStorage carStorage;
    @Autowired
    CustomerStorage customerStorage;
    // ... много кода по созданию и управлению ...
    ```

    **Стало (порядок):**
    ```
    @Autowired
    Hse hse;
    ...
    hse.addCustomer("Ivan", 6, 4, 150);
    hse.addPedalCar(6);
    hse.sell();
    System.out.println(hse.generateReport());
    ```

#### **Задача 2: Интегрировать новинку с помощью Адаптера**

**Проблема:** Мы хотим продавать новый товар — **Катамаран с колёсами**. 
Но наша система продаж (`CarStorage`) умеет работать только с объектами, реализующими интерфейс `Car` (или подобный). 
Наш новый катамаран имеет другое "поведение" (например, метод `isCompatible` не будет отрабатывать корректно`).

**Решение:** Реализовать паттерн **Адаптер**.

*   **Что нужно сделать?**
    1.  Создать класс `CatamaranOnWheels` (**Адаптер**), который:
        *   Будет реализовывать ожидаемый системой класс (`Car`).
        *   Внутри будет содержать ссылку на объект `Catamaran`.
        *   В методах `isCompatible`, `toString` и конструкоре будет переопределять нужное нам поведение 
        * (учтите что vin машин и адаптера должны отличаться, придумайте как).

*   **Как это сделать? (Схематично)**
    ```java
    // Новый класс, который мы не можем напрямую вставить в систему
    public class CatamaranWithWheels extends Car {
    private final Catamaran catamaran;

    public CatamaranWithWheels(Catamaran catamaran) {
     //TODO ваш код
    }

    @Override
    public boolean isCompatible(Customer customer) {
        // Используем проверку совместимости для автомобилей 
        // TODO ваш код
    }

    @Override
    public String toString() {
        // TODO ваш код
    }
    }
    ```
    Теперь мы можем создать `CatamaranOnWheels` и добавить в `CarStorage`, так как адаптер реализует класс `Car`. Напишите тест на это.

#### **Задача 3 (Дополнительная): **

Реализуйте задание из ADDITIONAL.md, можно через AI, однако покажите мне что вообще происходит. Так же нужны примеры отчетов.
поставлю 0.5 допом к посещению любой практики.

---

### **Итог вашей работы**

После выполнения занятия у вас должна получиться система, где:
1.  **Фасад `Hse`** скрыл всю внутреннюю кухню.
2.  **Адаптер `CatamaranOnWheels`** позволил безболезненно встроить новый функционал в старую систему.

**Для проверки:** Запустите усовершенствованный `KpoApplicationTest`. 
Он должен работать так же, как и раньше, но при этом продавать и новый вид транспорта, а его код должен стать значительно чище и понятнее.

Удачи в реализации! Помните, что вы не просто пишете код, а проектируете гибкую и надежную архитектуру.